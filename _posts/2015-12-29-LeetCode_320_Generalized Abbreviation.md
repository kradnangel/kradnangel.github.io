---
layout: post
title: LeetCode_320_Generalized Abbreviation
categories: [LeetCode]
tags: [LeetCode, python, string, recursion]
fullview: true
---
###[Question](https://leetcode.com/problems/generalized-abbreviation/)
Write a function to generate the generalized abbreviations of a word.

Example:
Given word = "word", return the following list (order does not matter):

	["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]

### Solution
Recursively enumerate every letter. There are two cases for one letter -- itself or '1'. 

All abbreviations of 'word' are generated by combining 'w'/'1' with the all abbreviations of 'ord'. Then recursively generate 'ord'.

When backtracking, if '1' meets an abbreviation starting with number, make the number plus one.

e.g.:

	'1' + '1rd' = '2rd'

           
notice that the number could be larger than '9'. So, we shouldn't only check the first character of the abbreviation. 

e.g.:

	'1' + '10s' = '11s'           
           
### Code
	class Solution(object):
        def generateAbbreviations(self, word):
            """
            :type word: str
            :rtype: List[str]
            """
            def s(word):
                if len(word) == 1:
                    return ['1', word]
                ans = []
                i = word[0]
                for abbs in s(word[1:]):
                    ans.append(i+abbs)
                    if (48<ord(abbs[0])<58):
                        j = 1
                        while (j < len(abbs)) and (48<=ord(abbs[j])<58):
                            j += 1
                        ans.append(str(int(abbs[:j])+1) + abbs[j:])
                    else:
                        ans.append('1'+abbs)
                return ans
            if word == '':
                return [""]
            else:
                return s(word)  
 